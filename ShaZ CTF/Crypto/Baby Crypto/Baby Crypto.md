# Baby Crypto (250 points)

## Description:
An encrypted message was generated using a custom crypto routine. Your task is to analyze the process and recover the original flag.

## Solution:
I first analyzed the provided Python script to understand how the encryption was performed. After reviewing the code, I noticed that the encryption process was fully deterministic and did not rely on any real randomness. The functions r() and m() were red herrings and had no impact on the final ciphertext.

The flag was first transformed using a custom keystream generated by a linear congruential generator. Each byte of the flag was XORed with this keystream and then rotated by a position-dependent number of bits. After that, the entire byte sequence was reversed. Since all these operations are reversible, the original data could be recovered once the correct keystream was known.

Next, the transformed flag was padded and encrypted using AES in CBC mode. The AES key and IV were derived from SHA-256 and MD5 hashes of parts of the keystream. Because the keystream itself depended only on the sum and length of the flag, I brute-forced reasonable values for these parameters.

I then wrote a solver script that regenerated the keystream for each candidate, derived the AES key and IV, and attempted to decrypt the ciphertext. Successful AES padding indicated a valid decryption. After decryption, I reversed the byte order, undone the bit rotations, and XORed the data again with the keystream to recover the original flag.

Once the correct parameters were found, the decrypted output matched the expected flag format, revealing the final flag.

Script I used:


```python
from Crypto.Cipher import AES
from Crypto.Util.Padding import unpad
import hashlib

# ciphertext from output.txt
with open("output.txt", "r") as f:
    cipher_hex = f.read().strip()

cipher_hex = "".join(cipher_hex.split())  # remove spaces/newlines
print("Hex length:", len(cipher_hex))
cipher = bytes.fromhex(cipher_hex)


# keystream generator
def p(s):
    x = s
    o = []
    for i in range(128):
        x = (x * 1103515245 + 12345 + i) & 0xffffffff
        o.append((x ^ (x >> 16)) & 0xff)
    return bytes(o)

# fake flag length is unknown, but AES padding tells us
# brute-force length is small (CTF flag)
for L in range(10, 50):
    for sm in range(1, 3000):
        s = ((sm << 3) ^ (L * 1337)) & 0xffffffff
        st = p(s)

        a = hashlib.sha256(st[:64]).digest()
        b = hashlib.sha256(st[64:] + a[:11]).digest()
        k = hashlib.sha256(b + a).digest()[:16]
        v = hashlib.md5(a).digest()

        try:
            pt = AES.new(k, AES.MODE_CBC, v).decrypt(cipher)
            pt = unpad(pt, 16)
        except:
            continue

        # reverse stage 2
        x = pt[::-1]
        x = bytearray(x)

        for i in range(len(x)):
            r = i % 6 + 1
            x[i] = ((x[i] >> r) | (x[i] << (8 - r))) & 0xff
            x[i] ^= st[(i * 9) % len(st)]

        try:
            flag = bytes(x)
            if flag.startswith(b"ShaZ{"):
                print(flag)
                exit()
        except:
            pass
```

The flag is: 
`ShaZ{1_7h0ugh7_it_w1ll_b3_4_h4rd_0n3_nvm!!!}`